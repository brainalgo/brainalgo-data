{
  "id": "linked-lists",
  "title": "Linked Lists Implementation",
  "description": "Understand linked list data structure, insertion, deletion, and traversal",
  "difficulty": "Intermediate",
  "duration": "25 min",
  "youtubeId": "dQw4w9WgXcQ",
  "content": {
    "introduction": "A linked list is a linear data structure where elements are stored in nodes, and each node contains data and a reference (or link) to the next node in the sequence. Unlike arrays, linked lists don't store elements in contiguous memory locations.",
    "sections": [
      {
        "title": "Linked List Structure",
        "content": "A linked list consists of nodes, where each node has two parts: data and a pointer to the next node. The first node is called the head, and the last node points to null.",
        "code": "// Node class definition\nclass ListNode {\n    int data;\n    ListNode next;\n    \n    // Constructor\n    public ListNode(int data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\n// LinkedList class\nclass LinkedList {\n    private ListNode head;\n    \n    public LinkedList() {\n        this.head = null;\n    }\n    \n    // Check if list is empty\n    public boolean isEmpty() {\n        return head == null;\n    }\n    \n    // Get size of list\n    public int size() {\n        int count = 0;\n        ListNode current = head;\n        while (current != null) {\n            count++;\n            current = current.next;\n        }\n        return count;\n    }\n}"
      },
      {
        "title": "Insertion Operations",
        "content": "There are three main ways to insert elements in a linked list: at the beginning, at the end, or at a specific position.",
        "code": "public class LinkedListInsertion {\n    \n    // Insert at beginning (O(1))\n    public void insertAtBeginning(int data) {\n        ListNode newNode = new ListNode(data);\n        newNode.next = head;\n        head = newNode;\n    }\n    \n    // Insert at end (O(n))\n    public void insertAtEnd(int data) {\n        ListNode newNode = new ListNode(data);\n        \n        if (head == null) {\n            head = newNode;\n            return;\n        }\n        \n        ListNode current = head;\n        while (current.next != null) {\n            current = current.next;\n        }\n        current.next = newNode;\n    }\n    \n    // Insert at specific position (O(n))\n    public void insertAtPosition(int data, int position) {\n        if (position < 0) {\n            throw new IllegalArgumentException(\"Position cannot be negative\");\n        }\n        \n        if (position == 0) {\n            insertAtBeginning(data);\n            return;\n        }\n        \n        ListNode newNode = new ListNode(data);\n        ListNode current = head;\n        \n        // Traverse to position - 1\n        for (int i = 0; i < position - 1 && current != null; i++) {\n            current = current.next;\n        }\n        \n        if (current == null) {\n            throw new IndexOutOfBoundsException(\"Position out of bounds\");\n        }\n        \n        newNode.next = current.next;\n        current.next = newNode;\n    }\n}"
      },
      {
        "title": "Deletion Operations",
        "content": "Similar to insertion, we can delete nodes from the beginning, end, or a specific position in the linked list.",
        "code": "public class LinkedListDeletion {\n    \n    // Delete from beginning (O(1))\n    public void deleteFromBeginning() {\n        if (head == null) {\n            throw new RuntimeException(\"List is empty\");\n        }\n        head = head.next;\n    }\n    \n    // Delete from end (O(n))\n    public void deleteFromEnd() {\n        if (head == null) {\n            throw new RuntimeException(\"List is empty\");\n        }\n        \n        if (head.next == null) {\n            head = null;\n            return;\n        }\n        \n        ListNode current = head;\n        while (current.next.next != null) {\n            current = current.next;\n        }\n        current.next = null;\n    }\n    \n    // Delete by value (O(n))\n    public boolean deleteByValue(int value) {\n        if (head == null) {\n            return false;\n        }\n        \n        if (head.data == value) {\n            head = head.next;\n            return true;\n        }\n        \n        ListNode current = head;\n        while (current.next != null && current.next.data != value) {\n            current = current.next;\n        }\n        \n        if (current.next == null) {\n            return false; // Value not found\n        }\n        \n        current.next = current.next.next;\n        return true;\n    }\n}"
      },
      {
        "title": "Traversal and Search",
        "content": "Traversing a linked list means visiting each node sequentially. We can also search for specific values during traversal.",
        "code": "public class LinkedListTraversal {\n    \n    // Display all elements (O(n))\n    public void display() {\n        if (head == null) {\n            System.out.println(\"List is empty\");\n            return;\n        }\n        \n        ListNode current = head;\n        System.out.print(\"List: \");\n        while (current != null) {\n            System.out.print(current.data + \" -> \");\n            current = current.next;\n        }\n        System.out.println(\"null\");\n    }\n    \n    // Search for a value (O(n))\n    public boolean search(int value) {\n        ListNode current = head;\n        while (current != null) {\n            if (current.data == value) {\n                return true;\n            }\n            current = current.next;\n        }\n        return false;\n    }\n    \n    // Get element at index (O(n))\n    public int get(int index) {\n        if (index < 0) {\n            throw new IllegalArgumentException(\"Index cannot be negative\");\n        }\n        \n        ListNode current = head;\n        for (int i = 0; i < index && current != null; i++) {\n            current = current.next;\n        }\n        \n        if (current == null) {\n            throw new IndexOutOfBoundsException(\"Index out of bounds\");\n        }\n        \n        return current.data;\n    }\n}"
      },
      {
        "title": "Advanced Operations",
        "content": "Let's implement some advanced linked list operations like reversing and detecting cycles.",
        "code": "public class AdvancedLinkedListOps {\n    \n    // Reverse linked list (O(n))\n    public ListNode reverse() {\n        ListNode prev = null;\n        ListNode current = head;\n        ListNode next = null;\n        \n        while (current != null) {\n            next = current.next;  // Store next\n            current.next = prev;  // Reverse link\n            prev = current;       // Move prev forward\n            current = next;       // Move current forward\n        }\n        \n        head = prev;  // Update head\n        return head;\n    }\n    \n    // Find middle element (Floyd's algorithm)\n    public ListNode findMiddle() {\n        if (head == null) return null;\n        \n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        return slow;\n    }\n    \n    // Detect cycle (Floyd's cycle detection)\n    public boolean hasCycle() {\n        if (head == null || head.next == null) {\n            return false;\n        }\n        \n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            \n            if (slow == fast) {\n                return true;  // Cycle detected\n            }\n        }\n        \n        return false;  // No cycle\n    }\n}"
      }
    ]
  }
}
